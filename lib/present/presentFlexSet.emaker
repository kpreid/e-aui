def presentFlexSet(flexSet, context) {
  # XXX add mouseover refreshes/refresh button/timer. XXX we need a general UI convention for no-notification-possible refreshes.
  
  def kit := context.kit()
  def box := kit.y()
  
  def itemToIndex := [].asMap().diverge()
  
  def refresh
  
  box."add(Component)"(kit.dropTarget(def addElement(new, _) { 
    refresh <- ()
    flexSet.addElement(new)
  }))
  
  def insert(item) { 
    def newIndex := box.getComponentCount() - 1
    itemToIndex.put(item, newIndex, true)
    
  	def entryFacet {
      to delete() { 
        refresh <- ()
        flexSet.remove(item)
      }
      to getValue() { return item }
    }
    box."add(Component, int)"(
      context.subPresentType(entryFacet, fn _,c {c.subPresent(entryFacet.getValue(), context.quoting())}, false),
      newIndex)
    
    box.revalidate()
    box.repaint(box.getVisibleRect()) # *sigh*, why is this necessary?
  }
  
  if (flexSet.__respondsTo("getFuture", 0)) {
    def [now, then] := flexSet.getFuture()
    for item in now { insert(item) }
    makeFollower(then, def followTarget {
      to addAll(items) { for item in items { insert(item) } }
      to removeAll(items) { 
        for item in items {
          def index := itemToIndex[item]
          box.remove(index)
          itemToIndex.removeKey(item)
          for otherItem => otherIndex in itemToIndex {
            if (otherIndex > index) {
              itemToIndex[otherItem] := otherIndex - 1
            }
          }
        }
        box.revalidate()
        box.repaint(box.getVisibleRect())
      }
    }, [].asMap())
    bind refresh := fn {}

  } else {
    bind refresh() {
      itemToIndex.removeAll()
      box.removeAll()
      for item in flexSet { insert(item) }
    }

    refresh()
  }

  
  return box
}
