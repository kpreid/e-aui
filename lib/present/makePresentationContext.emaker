# Copyright 2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")

def toKey                    := <elib:tables.makeTraversalKey>

def makePresentationContext(::"delegate", presenters, seen, kind, kit, privateBox, privateBrand) {
  return def presentationContext {
    to __optSealedDispatch(brand) { return switch (brand) {
      match ==privateBrand { privateBox }
      match _ { null }
    }}
    
    to kind() { return kind }
    to quoting() { return (kind != "incorporate") }
    to kit() { return kit }
    
    to subPresent(object, kind) {
      return presentationContext.subPresentType(
        object, 
        presenters[
          if (kind == false) { "incorporate" } else if (kind == true) { "reference" } else { kind }
        ], 
        kind)
    }
    
    to subPresentType(object, type, initKind) {
      # XXX cleanup kind-vs-quoting
      def kind := if (initKind == false) { "incorporate" } else if (initKind == true) { "reference" } else { initKind }
      def handleFailure(f) {
        return try { f() } catch problem { throw <- (problem); kit.failedPresent(object, problem) }
      }
    
      def key := toKey(object)
      def subC
      def subPrivateBox := ::"delegate".newContext(object, subC)
      bind subC := makePresentationContext(
        ::"delegate",
        presenters,
        seen.with(key),
        kind,
        kit,
        subPrivateBox,
        privateBrand)
      def c := ::"delegate".boundary(object, subC, if (seen.contains(key)) {
        handleFailure(fn { presenters["incorporate"]("CYCLE", subC) })
      } else {
        handleFailure(fn { type(object, subC) })
      })
      return c
    }
  }
}
