# Copyright 2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("one-method-object")

def <aui> := <import>[{def mqn := meta.context().getFQNPrefix().split("$")[0].split(".")
                       ".".rjoin(mqn(0, mqn.size() - 2)) + ".*"}]
def <awt>                    := <import:java.awt.*>
def <swing>                  := <import:javax.swing.*>


def JPanel__quasiParser      := <import:org.erights.ex.swing.JPanel__quasiParser>
def limitText                := <aui:data.limitText>
def makePresentationContext  := <aui:present.makePresentationContext>
def presentCommandRun        := <aui:present.presentCommandRun>
def presentGeneric           := <aui:present.presentGenericReference>
def makeDataFlavor           := <awt:datatransfer.makeDataFlavor>
def makeBrand                := <elib:sealing.makeBrand>

def dumpComponents(c, out) {
  out.lnPrint(c.__getAllegedType())
  def nest := out.indent()
  for d in c.getComponents() {
    dumpComponents(d, nest)
  }
  nest.close()
}

def makeSwingBackend(<unsafeAwt>, 
                     <unsafeSwing>, 
                     [=> defaultPresentGeneral, 
                      #=> defaultPresentReferenceGeneral,
                      => defaultPresentIcon], 
                     [=> makeFlexArgCommand, 
                      => CommandMessageDesc,
                      => SimpleMessageCommand,
                      => gatherCommands,
                      => CompleteCommand
                     ] | _,
                     stdout) {
  def backend
  def action := <aui:swing.action>
  def awtDropTarget := <unsafeAwt:dnd.makeDropTarget>
  def borderFactory := <swing:makeBorderFactory>
  def makeColor := <awt:makeColor>
  def makeJFrame := <unsafeSwing:makeJFrame>
  def makeJLabel := <swing:makeJLabel>
  def makeJButton := <swing:makeJButton>
  def makeImageIcon := <swing:makeImageIcon>
  def makeObjectSelector := <aui:swing.makeObjectSelectorAuthor>(awtDropTarget)
  def swingConstants := <swing:makeSwingConstants>
  def dragDropKit := <import:com.skyhunter.e.awt.dnd.dragDropKit>(<unsafeAwt>, def _(_) {})
  def attachContextMenu := <aui:swing.attachContextMenu>
  def VK_ENTER := <awt:event.makeKeyEvent>.getVK_ENTER()
  def makeJTextField := <swing:makeJTextField>
  def makeJPopupMenu := <swing:makeJPopupMenu>
  def toolkit := <unsafeAwt:makeToolkit>.getDefaultToolkit()
  
  def [contextPrivateSealer, contextPrivateUnsealer] := makeBrand("Swing backend wiring")
  def contextPrivateBrand := contextPrivateSealer.getBrand()
  
  def menuPresentKit {
    to button(name :String, actionThunk) {
      def component := <swing:makeJMenuItem>(name)
      action(component, actionThunk)
      return component
    }
    to text(text :String) {
      def component := <swing:makeJMenuItem>(text)
      component.setEnabled(false)
      return component
    }
  }
  
  def iconPresentKit {
    to image(resource) {
      return makeImageIcon(resource)
    }
  }
  
  def stubPrivate := contextPrivateSealer.seal([
    "addListeners" => fn component {},
    "borderControlListener" => def sink { match msg {} },
  ])
  
  def stubDelegate {
    to newContext(object, context) {
      return stubPrivate
    }
    to boundary(_, _, c) { 
      return c 
    }
  }
  
  def menuContext := makePresentationContext(
    stubDelegate,
    Ref.broken("There is no generic presenter for menus."),
    [].asSet(), false, menuPresentKit,
    stubPrivate, contextPrivateBrand)

  def iconContext := makePresentationContext(
    stubDelegate,
    defaultPresentIcon,
    [].asSet(), false, iconPresentKit,
    stubPrivate, contextPrivateBrand)
  
  # XXX this is generic and doesn't belong in the backend
  def runToWindow(title, command, originC) {
    backend.openFrame(title, 
                      presentCommandRun(backend.getRootContext(), 
                                        command.run()),
                      originC)
  }
  
  # XXX this is generic and doesn't belong in the backend
  def presentAMCommand(command :CompleteCommand, context, selected) {
    def [commandLabel, resultLabelTh] := switch ([command.getCommand(), command.getArgs()]) {
      match [sc :SimpleMessageCommand ? (sc.getRecipient() == selected), []] {
        def verb := sc.getVerb()
        [verb,
         fn { `$selected.$verb()` }]
      }
      match [subCmd, [==selected]] {
        [E.toQuote(subCmd),
         fn { `$subCmd($selected)` }]
      }
      match [makeCmd :SimpleMessageCommand ? (makeCmd.getRecipient() == makeFlexArgCommand && makeCmd.getMessageDesc().getVerb() == "empty"), [subCmd :SimpleMessageCommand]] {
        # XXX present subCmd instead?
        def md := subCmd.getMessageDesc()
        def verb := md.getVerb()
        def arity := md.getParams().size()
        [verb + "." * (2 + arity),
         fn { `$selected.$verb/$arity` }]
      }
      match _ {
        [def s := E.toQuote(command), fn { s }]
      }
    }
  
    def mi := context.kit().button(commandLabel, fn {
      runToWindow(resultLabelTh(), command, mi)
    })
  
    return mi
  }
  
  def deepGatherCommands(menu, context) {
    escape stop {
      def [[=> enclosingContext, => object] |_] exit stop := 
        contextPrivateUnsealer.amplify(context)
      return when (def commands := gatherCommands(object)) -> {
        menu."add(Component)"(
          menuPresentKit.text(`(${limitText(E.toQuote(object), 30)})`)) 
        # XXX polish title
        for command in commands {
          menu."add(Component)"(presentAMCommand(command, menuContext, object))
        }
        deepGatherCommands(menu, enclosingContext)
      } 
    } catch _ {
      return
    }
  }
  
  def addStandardEventHandlers(component, object, outerContext) {
    def [hooks] := contextPrivateUnsealer.amplify(outerContext)
    
    dragDropKit.setupLocalDragSource(component, fn { object })
    hooks["addListeners"](component)
  
    attachContextMenu(component, fn {
      def m := makeJPopupMenu()      
      when (deepGatherCommands(m, outerContext)) -> {
        m.addPopupMenuListener(hooks["borderControlListener"])
        m
      } catch p {
        toolkit.beep() # besides the tracelog
        throw <- (p)
        m
      }
    })
  }

  def setupDrop := <import:com.skyhunter.e.awt.dnd.setupDropFuncAuthor> \
                     (awtDropTarget, fn _ {})
  def prepDrop(component, reactor) :void {
    # code copied and modified from esrc/caplets/capEdit/capEdit.caplet. XXX make it nicer in using Java's D&D correctly
    setupDrop(component, [
      makeDataFlavor(makeDataFlavor.getJavaJVMLocalObjectMimeType() +
                     "; class=java.awt.dnd.DropTargetEvent") =>
        reactor])
  }
  
  def presentKit {
    to failedPresent(object, problem) {
      # XXX this probably should not be in the kit at all, but a private provision to the presentation context
      # XXX need to decide on a presentation for broken refs, that is distinct from this
      # XXX make this look more internal-errorish. cf Squeak morph-drawing-error-morph
      def label := presentKit.text(`Presenter: $problem`)
      label.setBorder(borderFactory.createLineBorder(makeColor.getRed()))
      return label
    }
  
    /** XXX what does this name mean? */
    to plabel(name :String, optIconPresenter, context, object, getDoubleClickCommand) {
v v v v v v v
*************
    
      def iconContext := makePresentationContext(fn _,_,c {[c,[].asMap()]}, def _.get(_) {return defaultPresentIcon}, [].asSet(), false, [].asMap(), iconPresentKit)
^ ^ ^ ^ ^ ^ ^
      def icon := if (optIconPresenter != null) {
        iconContext.subPresentType(object, optIconPresenter, false)
      } else { 
        iconContext.subPresent(object, false)
      }
    
      # XXX object arg shouldn't be present; instead the context should be asked to install these things
      def label := makeJLabel(name, icon, swingConstants.getLEADING())
      
      addStandardEventHandlers(label, object, context)
      
      label.addMouseListener(def doubleClickListener {
        to mouseReleased(e) { try {
          if (e.getClickCount() == 2) {
            def command := getDoubleClickCommand()
            runToWindow(E.toString(command), command, label)
          }
        } catch p { throw <- (p) } }
        match _ {}
      })
      
      return label
    }
    
    to button(name :String, actionThunk) {
      def component := makeJButton(name)
      action(component, actionThunk)
      return component
    }

    /** XXX this ought to not exist here */
    to getObjectSelectorPresenter() { return makeObjectSelector }

    to dropTarget(handler) {
      # XXX review the interface for this
      def outer := JPanel``
    
      prepDrop(outer, def pdOuter(obj) {
        try {
          # XXX need a better way to cancel the drag
          handler(obj, null)
        } catch p { 
          throw <- (p)
        }
      })
      outer.setBorder(borderFactory.createLoweredBevelBorder())
      return outer
    }

    to text(s :String) {
      return makeJLabel(s)
    }

    to _textLineCommandField(handler) {
      def field := makeJTextField()
      field.addKeyListener(def enterKeyListener {
        to keyPressed(e) :void { try {
          if (e.getKeyCode() == VK_ENTER) {
            handler <- (field.getText())
            field.setText("")
          }
        } catch p { throw <- (p) } }
        match _ {}
      })
      return field
    }

    #match [dn ? via (["x" => 0, "y" => 1].fetch) dir, components]
    match [dn ? (["x" => 0, "y" => 1] =~ [(dn) => dir]|_), components] {
      def box := <swing:makeBox>(dir)
      for c in components { 
        box."add(Component)"(c) 
      }
      box
    }
  }

  def normalBorder := borderFactory.createEmptyBorder(2, 2, 2, 2)
  def boundaryBorder := borderFactory.createRaisedBevelBorder()
  def activeBorder := borderFactory.createBevelBorder(
    { #<swing:border.BevelBorder>.getRAISED() -- XXX erroneously unsafe
      0 },
    makeColor."run(float, float, float)"(0.7, 0.7, 1.0),
    makeColor."run(float, float, float)"(0.4, 0.4, 0.7))

  def swingDelegate {
    to newContext(object, context) {
      def container
      var mouseover := [].asSet()
      var active := false
      
      def updateBorder() {
        container.setBorder(
          if (active) { activeBorder } else if (mouseover.size() > 0) { boundaryBorder } else { normalBorder } )
      }
      
      def addListeners(c) {
        c.addMouseListener(def mouseOverUpdateListener {
          to mouseEntered(event) :void { try {
            mouseover with= mouseOverUpdateListener
            updateBorder()
            if (false) {
              dumpComponents(c, stdout)
              stdout.println()
            }
          } catch p { throw <- (p) } }
          to mouseExited(event) :void { try {
            mouseover without= mouseOverUpdateListener
            updateBorder()
          } catch p { throw <- (p) } }
          match _ {}
        })
      }
      
      def borderControlListener { # XXX this needs renaming now
        to popupMenuWillBecomeInvisible(e) { try { 
          active := false
          updateBorder()
        } catch p { throw <- (p) } }
        to popupMenuWillBecomeVisible(e) { try {
          active := true
          updateBorder()
        } catch p { throw <- (p) } }
        match msg {}
      }
      
      return contextPrivateSealer.seal([
        => borderControlListener, 
        => addListeners,
        => container,
        => container__Resolver,
        => updateBorder,
      ])
    }
    
    to boundary(object, context, content) {
      def [[
        => addListeners,
        => container,
        => container__Resolver,
        => updateBorder
      ] | _] := contextPrivateUnsealer.amplify(context)
      
     bind container := JPanel`$content`
     updateBorder()
     addListeners(container)
     addStandardEventHandlers(container, object, context)
  
      return container
    }
  }
  
  def [closedIcon, openIcon] := {
    def renderer := <unsafeSwing:tree.DefaultTreeCellRenderer>()
    [renderer.getClosedIcon(), renderer.getOpenIcon()]
  }
  def defaultPresentReferenceGeneral(object, context) {
    def toggle := makeJButton(closedIcon)
    def hole := JPanel``
    def open
    var currentAction := open
    
    def close() {
      toggle.setIcon(closedIcon)
      currentAction := open
      hole.removeAll()
      hole.revalidate()
    }
    bind open() {
      toggle.setIcon(openIcon)
      currentAction := close
      hole."add(Component)"(defaultPresentGeneral(object, context))
      hole.revalidate()
    }
    
    action(toggle, fn { currentAction() })
    
    return JPanel`$toggle   ${presentGeneric(object, context)}
                  $hole.X.Y >`
  }
  
  def defaultPresenters := [
    "view" => defaultPresentGeneral,
    "incorporate" => defaultPresentGeneral,
    "reference" => defaultPresentReferenceGeneral,
  ]

v v v v v v v
  def contextPrivateBox := contextPrivateSealer.seal(Ref.broken("no hooks in root context"))

  def rootContext := makePresentationContext(swingDelegate, defaultPresentGeneral, [].asSet(), true, presentKit, contextPrivateBox, contextPrivateBrand)
*************
  def rootContext := makePresentationContext(makeSwingBoundary, defaultPresenters, [].asSet(), true, Ref.broken("no hooks"), presentKit)
^ ^ ^ ^ ^ ^ ^

  return bind backend {
    to getRootContext() { return rootContext }
    to getPresentKit() { return presentKit }
    /** XXX decide whether "Frame" name is to stay */
    to openFrame(title, component, optRel) {
      def frame := makeJFrame(title)
    
      def sp := <swing:makeJScrollPane>()
        #sp.setPreferredSize(<awt:Dimension>(320,320))
        #sp.setVerticalScrollBarPolicy(<swing:ScrollPaneConstants>.getVERTICAL_SCROLLBAR_ALWAYS())
      sp.getViewport()."add(Component)"(component)
    
      frame.setContentPane(sp)
      frame.pack()
      if (optRel != null) { 
        frame.setLocationRelativeTo(optRel)
      } else {
        if (frame.__respondsTo("setLocationByPlatform", 1)) {
          frame.setLocationByPlatform(true)
        }
      }
      frame.show()
      return frame
    }
  }
}
